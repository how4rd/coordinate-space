<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Coordinate Space Visualization</title>
		<script>
			"use strict";

			function draw() {
				const canvas = document.getElementById('canvas');
				const ctx = canvas.getContext('2d');
			}

			class Matrix {
				constructor(contents) {
					this.contents = contents;
					this.rows = contents.length;
					this.cols = contents[0].length;
				}

				// get the contents of the Matrix at index (row, col)
				getIndex(row, col) {
					if (row < 0 || row >= this.rows || col < 0 || col >= this.cols) {
						return new Error("Invalid index passed to Matrix.getIndex.");
					}
					return this.contents[row][col];
				}

				// set the contents of the Matrix at index (row, col)
				setIndex(row, col, value) {
					if (row < 0 || row >= this.rows || col < 0 || col >= this.cols) {
						return new Error("Invalid index passed to Matrix.setIndex.");
					}
					this.contents[row][col] = value;
				}

				// return the specified row as a Vector
				getRow(rowIndex) {
					if (rowIndex < 0 || rowIndex >= this.rows) {
						return new Error("Invalid index passed to Matrix.getRow.");
					}

					return new Vector(this.contents[rowIndex]);
				}

				// return the specified column as a Vector
				getCol(colIndex) {
					if (colIndex < 0 || colIndex >= this.cols) {
						return new Error("Invalid index passed to Matrix.getCol.");
					}

					return new Vector(this.contents.map(row => row[colIndex]));
				}

				// return the sum of the two Matrices
				static add(matrix1, matrix2) {
					if (matrix1.rows != matrix2.rows || matrix1.cols != matrix2.cols) {
						throw new Error("Arguments to Matrix.add don't have the same dimensions.");
					}

					let sum = [];
					for (let row = 0; row < matrix1.rows; row++) {
						sum[row] = [];
						for (let col = 0; col < matrix1.cols; col++) {
							sum[row][col] = matrix1.getIndex(row, col) + matrix2.getIndex(row, col);
						}
					}

					return new Matrix(sum);
				}

				// return the product of the two Matrices
				static multiply(matrix1, matrix2) {
					if (matrix1.cols != matrix2.rows) {
						throw new Error("For Matrix.multiply, the first argument's column count doesn't equal the second's row count.");
					}

					let product = [];
					for (let rowIndex = 0; rowIndex < matrix1.rows; rowIndex++) {
						product[rowIndex] = [];
						for (let colIndex = 0; colIndex < matrix2.cols; colIndex++) {
							product[rowIndex][colIndex] = Vector.dot(matrix1.getRow(rowIndex), matrix2.getCol(colIndex));
						}
					}

					return new Matrix(product);
				}
			}

			class Vector extends Matrix {
				constructor(contents) {
					super(contents);

					// always make the Vector a row vector
					// see https://stackoverflow.com/a/10865042
					this.contents = [].concat.apply([], contents);
				}

				// return the dot product of the two Vectors
				static dot(vector1, vector2) {
					if (vector1.contents.length != vector2.contents.length) {
						throw new TypeError("Arguments to Vector.dot don't have the same dimensions.");
					}

					let output = 0;
					for (let i = 0; i < vector1.contents.length; i++) {
						output += vector1.contents[i] * vector2.contents[i];
					}

					return output;
				}
			}

			class Point {
				constructor() {
					if (this.constructor == Point) {
						throw new TypeError("Cannot instantiate abstract class Point.");
					}
				}

				toMatrix() {
					throw new Error("Function 'toMatrix' must be implemented.");
				}

				print() {
					throw new Error("Function 'print' must be implemented.");
				}

				draw() {
					throw new Error("Function 'draw' must be implemented.");
				}

				static add(point1, point2) {
					throw new Error("Function 'add' must be implemented.");
				}
			}

			class xyPoint extends Point {
				constructor(x, y) {
					this.x = x;
					this.y = y;
				}

				toMatrix() {
					return;  // @TODO
				}

				print() {
					return;  // @TODO
				}

				draw() {
					return;  // @TODO
				}

				static add(point1, point2) {
					return;  // @TODO
				}
			}

			class uvwPoint extends Point {
				constructor(u, v, w) {
					this.u = u;
					this.v = v;
					this.w = v;
				}

				toMatrix() {
					return;  // @TODO
				}

				print() {
					return;  // @TODO
				}

				draw() {
					return;  // @TODO
				}

				static add(point1, point2) {
					return;  // @TODO
				}
			}

			class uvwLineSegment {
				constructor(point1, point2) {
					this.point1 = point1;
					this.point2 = point2;
				}

				print() {
					return;  // @TODO
				}

				draw() {
					return;  // @TODO
				}
			}
		</script>
	</head>
	<body onload="draw();">
		<canvas id="canvas" width="200" height="200" style="border: 1px solid red;"></canvas>
	</body>
</html>
